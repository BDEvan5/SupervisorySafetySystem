---
title: "Derivation of Viable States"
author: "Benjamin Evans"
date: "22/09/2021"
output: 
  html_document: 
    fig_height: 3
    fig_caption: yes
    fig_width: 5
    toc: yes
---

# Introduction

## Problem Statement

The problem is to design a safety system that ensures that the vehicle does not crash irrespective of the actions selected by the local planner.

## Methodology

The design methodology that is followed is to find the limiting point at which a state is guaranteed to crash.
Inverse logic is used to state that if a state is not guaranteed to lead to a crash, then a safe action exists.
Therefore, the problem is transformed to determine where the boundary is for calculating if a state will lead to a crash.

We systematically build the solution starting with a simple model and expanding it to take higher order dynamics into account.
A proof of concept has already been demonstrated for a holonomic robot and this definition is now expanded to a non-holonomic racing vehicle.

The state space of the vehicle consists of 5 numbers. 
The method in determining if the vehicle is in a safe region or not is to check if it is able to move out of the way of an obstacle before colliding with the obstacle.
This is done by generating a region that is declared unsafe and ensuring that the vehicle never enters the region.
The aim is that the shape of the region is such that if you are not inside of it, then there always exists and action within the action space such that you will not move inside the the unsafe region.

## Theory Basis

The determining factor used to classify a state is the distance to the obstacle. 
The formula below is derived for calculating the critical distance to the obstacle.

$$  d^* = \sqrt{\frac{2 L w}{\tan(\delta_\text{max})} - w^2},  $$


# Progress

Currently, I have implemented the algorithm and for vehicles travelling straight it appears to be working.
My problem is that when the vehicle orientation changes, the safe region isn't updated accordingly.


## Review on Work Habbits

Over the last two months since coming back from Knysna, very little progress has been made on the project.
For the first 4 weeks, the focus of my time was the proposal and that is all that I worked on.
Since then, work progress has been slow.
In the first week since after handing in, I was recovering and experiencing normal post deadline slump.
This lasted until last week Monday when I had the proposal and received the upgrade.
Since then I have been a bit too starry eyed to be able to work hard.
Last week, I did make definite progress on optimising the learning formulation and I wrote a comprehensive report on the matter.
This week, I have shifted my focus to the safety system.

In my attempts at a safety system, I have worked on an isolated test setup to see how the safety system is being defined.
Yesterday, I wrote a report on how it is working and I was satisfied with the images that it produced of defining the region for different vehicle orientations.

## Review on Work

The derivation appears to work at present. I suspect that there are still several implementation issues to sort out. 
Currently, I do not know why the system is not working as expected. It would appear that the individual components are supposed to be working. 


# Going Forward

__Aim:__ To publish an article by the end of the year on the safety system with extensive test results in the official F1/10th simulator.

## Planned Progression

The following progression is used on how to build the research to a final solution and paper:

- Upgrade the system to non-holonomic vehicles
- Upgrade the functionality to take multiple obstacles and wall boundaries into account
- Increase the system order to take $\dot \delta$ into account
- Test the system in my simulator with straight lines
- Test the system in the official simulator with curvy lines
- Formulate a learning formulation and train an agent online in the simulator

## Tasks to Complete

1. Debug the non-holonomic vehicle system. I don't know where the problem is. 
  - It might be an idea to start again and implement it from the beginning. This will help to eliminate other bugs.
2. Implement the system in a simulation and check that the edge cases work.
3. Write tests for every subsystem that you do.


## Considerations & Ideas

- Discretise the action space, and possible the state space too. Then use a look-up table to check what possible actions are allowed for each state.
- Work logically and systematically. Focus on one task at a time. 
- Delete Telegram
- Be driven but not stressed and work hard.
- Keep writing reports on the work that I am doing
- Break tasks up into managable lists of small jobs that I can complete






